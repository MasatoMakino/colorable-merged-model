(()=>{"use strict";var e,n={496:(e,n,t)=>{class r{constructor(e){this.model=e,this.isOn=!0,this.switchColor=()=>{this.isOn=!this.isOn;const e=[1,1,1,.2],n=[1,1,1,.8],t=this.model.body?.material;t.colors.changeColor(this.isOn?e:[1,0,0,.2],1),t.colors.changeColor(this.isOn?e:[0,1,0,.2],-1);const r=this.model.edge?.material;r.colors.changeColor(this.isOn?n:[1,0,0,.8],1),r.colors.changeColor(this.isOn?n:[0,1,0,.8],-1)},setInterval(this.switchColor,3e3),this.switchColor()}}var i=t(71);class o extends i.Kj0{constructor(e){super(),this.geometryMerger=new b(this,e)}}class a extends i.ejS{constructor(e){super(),e.edgeDetail=e.edgeDetail??7,this.geometryMerger=new x(this,e)}}class s extends i.ZAu{constructor(e){super(),this.getGeometryID=e=>{const n=e.match(/.*_.*_(\d*)/);if(null==n)throw new Error(`Invalid name: ${e}`);return Number(n[1])},null!=e.bodyOption&&(this.body=new o(e.bodyOption),this.add(this.body)),null!=e.edgeOption&&(this.edge=new a(e.edgeOption),this.add(this.edge))}async merge(){await Promise.all([this.body?.geometryMerger.merge(),this.edge?.geometryMerger.merge()])}}s.MODEL_INDEX="MODEL_INDEX";const l=new i.Pa4,c=new i.Pa4,d=new i.Pa4,u=new i.CJI;class g extends i.u9r{constructor(e=null,n=1,t){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:n},null!==e){const r=10**(t?.precisionPoints??6),o=Math.cos(i.M8C.DEG2RAD*n),a=e.getIndex(),s=e.getAttribute("position"),m=a?a.count:s.count,f=[0,0,0],p=["a","b","c"],h=new Array(3),_=new Map,v=[];for(let e=0;e<m;e+=3){a?(f[0]=a.getX(e),f[1]=a.getX(e+1),f[2]=a.getX(e+2)):(f[0]=e,f[1]=e+1,f[2]=e+2);const{a:n,b:i,c:l}=u;if(n.fromBufferAttribute(s,f[0]),i.fromBufferAttribute(s,f[1]),l.fromBufferAttribute(s,f[2]),u.getNormal(d),h[0]=g.hybridtaus(Math.round(n.x*r),Math.round(n.y*r),Math.round(n.z*r),t?.seed),h[1]=g.hybridtaus(Math.round(i.x*r),Math.round(i.y*r),Math.round(i.z*r),t?.seed),h[0]!==h[1]&&(h[2]=g.hybridtaus(Math.round(l.x*r),Math.round(l.y*r),Math.round(l.z*r),t?.seed),h[1]!==h[2]&&h[2]!==h[0]))for(let e=0;e<3;e++){const n=(e+1)%3,r=h[e],i=h[n],a=u[p[e]],s=u[p[n]],l=g.hybridtaus(r,i,0,t?.seed),c=g.hybridtaus(i,r,0,t?.seed),m=_.get(c);void 0!==m?(d.dot(m.normal)<=o&&(v.push(a.x,a.y,a.z),v.push(s.x,s.y,s.z)),_.delete(c)):_.set(l,{index0:f[e],index1:f[n],normal:d.clone()})}}_.forEach((e=>{const{index0:n,index1:t}=e;l.fromBufferAttribute(s,n),c.fromBufferAttribute(s,t),v.push(l.x,l.y,l.z),v.push(c.x,c.y,c.z)})),this.setAttribute("position",new i.a$l(v,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static taus(e,n,t,r,i){return((e&i)<<n^(e<<t^e)>>>r)>>>0}static hybridtaus(e,n,t,r=255){const i=e=>e>>>0;return e=g.taus(e,13,19,12,4294967294),n=g.taus(n,2,25,4,4294967288),t=g.taus(t,3,11,17,4294967280),r=i(1664525*r+1013904223),i(e^n^t^r)}}var m=t(75);class f extends i.jyz{constructor(e,n){if(super(e),this.isColorableMergedMaterial=!0,this.initDefine=e=>{this.defines={INDEX:e}},0===n)throw new Error("ColorableMergedMaterialには少なくとも1つ以上のTweenableColorが必要です。\n        このMaterialに紐づけられたTweenableColoMapには1つもTweenableColorが登録されていません。");this.isColorableMergedMaterial=!0,this.initDefine(n)}static getColorUniform(e){return{colors:{value:new Array(e).fill(0).map((()=>new i.Ltg(1,1,1,.5)))}}}}class p extends f{constructor(e,n){super({vertexShader:"\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nattribute float MODEL_INDEX;\nvarying float colorTableIndex;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n  \n  colorTableIndex = MODEL_INDEX;\n}\n",fragmentShader:"\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying float colorTableIndex;\nuniform vec4[INDEX] colors;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n  //#include <color_fragment>\n  diffuseColor *= colors[int(colorTableIndex)];\n    \n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"},e.getSize()),this.colors=e,this.uniforms=p.getBasicUniforms(e.getSize()),this.transparent=!0,this.blending=n?.blending??i.bdR,this.side=n?.side??i.Wl3,e.setMaterial(this),e.updateUniformsAll()}static getBasicUniforms(e){return i.rDY.merge([m.rBU.common,m.rBU.specularmap,m.rBU.envmap,m.rBU.aomap,m.rBU.lightmap,m.rBU.fog,f.getColorUniform(e)])}}class h extends f{constructor(e,n){super({vertexShader:"\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nattribute float MODEL_INDEX;\nvarying float colorTableIndex;\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n    \n  colorTableIndex = MODEL_INDEX;\n}\n",fragmentShader:"\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying float colorTableIndex;\nuniform vec4[INDEX] colors;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t//#include <color_fragment>\n  diffuseColor *= colors[int(colorTableIndex)];\n    \n  outgoingLight = diffuseColor.rgb; // simple shader\n\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}\n"},e.getSize()),this.colors=e,this.uniforms=h.getBasicUniforms(e.getSize()),this.depthWrite=n?.depthWrite??!0,this.transparent=!0,e.setMaterial(this),e.updateUniformsAll()}static getBasicUniforms(e){return i.rDY.merge([m.rBU.common,m.rBU.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}},f.getColorUniform(e)])}}var _=t(993);class v{constructor(e,n){this.geometries=[],this.object3D=e,this.option=n}async add(e,n,t){const r=await this.convert(e),o=n.getUniformIndex(t),a=function(e){return e.getAttribute("position").count}(r),l=new Uint16Array(a);for(let e=0;e<a;e++)l[e]=o;const c=new i.TlE(l,1);r.setAttribute(s.MODEL_INDEX,c),this.geometries.push(r)}async convert(e){return e}async merge(){0!==this.geometries.length?this.object3D.geometry=_.n4(this.geometries):this.object3D.parent?.remove(this.object3D)}}class b extends v{async convert(e){return e.deleteAttribute("uv"),e}}class x extends v{async convert(e){return this.option.useFastEdgesGeometry?new g(e,this.option.edgeDetail):new i.TOt(e,this.option.edgeDetail)}}var y=t(647),w=t(984),M=t(146);class D extends M.v{constructor(e){super(),this.uniformName=e,this.colors=new Map,y.k7.start()}setMaterial(e){this.material=e}static getColorMapKey(e){return`${e}`}add(e,n){const t=new y.ZM(255*e[0],255*e[1],255*e[2],e[3]);this.colors.set(D.getColorMapKey(n),t),t.on("onUpdate",(()=>{this.updateUniform(t)}))}get(e){return this.colors.get(D.getColorMapKey(e))}getUniformIndex(e){return[...this.colors.keys()].indexOf(D.getColorMapKey(e))}getUniformIndexFromColor(e){return[...this.colors.values()].indexOf(e)}getSize(){return this.colors.size}changeColor(e,n,t){t=t??{},t.now??=performance.now(),t.duration??=1e3,t.easing??=w.oY.Cubic.Out;const r=this.get(n);r?.change(255*e[0],255*e[1],255*e[2],e[3],t.duration,{easing:t.easing,startTime:t.now})}updateUniformsAll(){this.colors.forEach((e=>{this.updateUniform(e)}))}updateUniform(e){if(null==this.material)return;const n=this.material.uniforms[this.uniformName].value;if(null==n)return void console.error(`対象のマテリアルに、${this.uniformName}という名前のuniformが存在しません。${this.material.name}のuniform生成処理にこの名前のuniformを追加してください。`);const t=this.getUniformIndexFromColor(e),r=e.getAttribute();n[t].set(...r)}}const C=async(e,n,t,r,o,a,s)=>{const l=.1,c=new i.DvJ(l,l,l),d=n=>n<e/2?-1:1,u=d(n)*d(t)*d(r),g=n=>3*l*(n-e/2);c.translate(g(n),g(t),g(r)),a.add([1,1,1,.2],u),s.add([1,1,1,.8],u),await(o.body?.geometryMerger.add(c,a,u)),await(o.edge?.geometryMerger.add(c,s,u))};var O=t(12),E=t(304);window.onload=async()=>{const{scene:e}=(e=>{const n=new i.xsS,t=new i.cPb(45,1280/720,1,6e4);t.position.set(0,0,15);const r=new m.CP7({antialias:!0});r.setSize(1280,720),r.setClearColor(new i.Ilk(0)),document.body.appendChild(r.domElement);const o=document.createElement("div");document.body.appendChild(o),new O.z(t,r.domElement);const a=new E.Z,s=()=>{a.begin(),r.render(n,t),a.end(),o.innerText=JSON.stringify(r.info.render),requestAnimationFrame(s)};return s(),{scene:n,camera:t}})(),n=await async function(e=20,n){n=n??"webgl";const t=new s({bodyOption:{color:[1,1,1,.2]},edgeOption:{color:[1,1,1,.8]}}),r=new D("colors"),i=new D("colors");return await(async(e,n,t,r)=>{const i=[];for(let o=0;o<e;o++)for(let a=0;a<e;a++)for(let s=0;s<e;s++)i.push(C(e,o,a,s,n,t,r));await Promise.all(i),await n.merge()})(e,t,r,i),((e,n,t,r)=>{e.body&&(e.body.material=new r.bodyMaterialClass(n)),e.edge&&(e.edge.material=new r.edgeMaterialClass(t))})(t,r,i,{bodyMaterialClass:p,edgeMaterialClass:h}),t}();e.add(n),new r(n)}}},t={};function r(e){var i=t[e];if(void 0!==i)return i.exports;var o=t[e]={exports:{}};return n[e](o,o.exports,r),o.exports}r.m=n,e=[],r.O=(n,t,i,o)=>{if(!t){var a=1/0;for(d=0;d<e.length;d++){for(var[t,i,o]=e[d],s=!0,l=0;l<t.length;l++)(!1&o||a>=o)&&Object.keys(r.O).every((e=>r.O[e](t[l])))?t.splice(l--,1):(s=!1,o<a&&(a=o));if(s){e.splice(d--,1);var c=i();void 0!==c&&(n=c)}}return n}o=o||0;for(var d=e.length;d>0&&e[d-1][2]>o;d--)e[d]=e[d-1];e[d]=[t,i,o]},r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.j=577,(()=>{var e={577:0};r.O.j=n=>0===e[n];var n=(n,t)=>{var i,o,[a,s,l]=t,c=0;if(a.some((n=>0!==e[n]))){for(i in s)r.o(s,i)&&(r.m[i]=s[i]);if(l)var d=l(r)}for(n&&n(t);c<a.length;c++)o=a[c],r.o(e,o)&&e[o]&&e[o][0](),e[o]=0;return r.O(d)},t=self.webpackChunk_masatomakino_colorable_merged_model=self.webpackChunk_masatomakino_colorable_merged_model||[];t.forEach(n.bind(null,0)),t.push=n.bind(null,t.push.bind(t))})();var i=r.O(void 0,[736],(()=>r(496)));i=r.O(i)})();