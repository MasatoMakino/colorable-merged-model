(()=>{"use strict";var e,n={496:(e,n,t)=>{class r{constructor(e){this.model=e,this.isOn=!0,this.switchColor=()=>{this.isOn=!this.isOn;const e=[1,1,1,.2],n=[1,1,1,.8],t=this.model.body?.material;t.colors.changeColor(this.isOn?e:[1,0,0,.2],1),t.colors.changeColor(this.isOn?e:[0,1,0,.2],-1);const r=this.model.edge?.material;r.colors.changeColor(this.isOn?n:[1,0,0,.8],1),r.colors.changeColor(this.isOn?n:[0,1,0,.8],-1)},setInterval(this.switchColor,3e3),this.switchColor()}}var i=t(71);class o extends i.Kj0{constructor(e){super(),this.geometryMerger=new y(this,e)}}class a extends i.ejS{constructor(e){super(),e.edgeDetail=e.edgeDetail??7,this.geometryMerger=new b(this,e)}}class s extends i.ZAu{constructor(e){super(),this.getGeometryID=e=>{const n=e.match(/.*_.*_(\d*)/);if(null==n)throw new Error(`Invalid name: ${e}`);return Number(n[1])},null!=e.bodyOption&&(this.body=new o(e.bodyOption),this.add(this.body)),null!=e.edgeOption&&(this.edge=new a(e.edgeOption),this.add(this.edge))}async merge(){await Promise.all([this.body?.geometryMerger.merge(),this.edge?.geometryMerger.merge()])}}s.MODEL_INDEX="MODEL_INDEX";const l=new i.Pa4,c=new i.Pa4,d=new i.Pa4,u=new i.Pa4,g=new i.Pa4;class f extends i.u9r{constructor(e=null,n=1,t){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:n},null!==e){const r=10**(t?.precisionPoints??6),o=Math.cos(i.M8C.DEG2RAD*n),a=e.getIndex(),s=e.getAttribute("position"),m=a?a.count:s.count,p=f._indexArray,h=f._hashArray,_=1664525*(t?.seed??255)+1013904223>>>0,v=m,x=new Uint32Array(v),y=new Uint32Array(v),b=new Float32Array(v),w=new Float32Array(v),M=new Float32Array(v),D=new Map;let C=0;const O=new Float32Array(2*m*3);let A=0;const E=(e,n,t)=>((e=((4294967294&e)<<13^(e<<19^e)>>>12)>>>0)^(n=((4294967288&n)<<2^(n<<25^n)>>>4)>>>0)^(t=((4294967280&t)<<3^(t<<11^t)>>>17)>>>0)^_)>>>0;for(let e=0;e<m;e+=3){a?(p[0]=a.getX(e),p[1]=a.getX(e+1),p[2]=a.getX(e+2)):(p[0]=e,p[1]=e+1,p[2]=e+2),d.fromBufferAttribute(s,p[0]),u.fromBufferAttribute(s,p[1]),g.fromBufferAttribute(s,p[2]);const n=u.x-d.x,t=u.y-d.y,i=u.z-d.z,l=g.x-d.x,c=g.y-d.y,f=g.z-d.z;let m=t*f-i*c,_=i*l-n*f,v=n*c-t*l;const I=Math.sqrt(m*m+_*_+v*v);if(I>0){const e=1/I;m*=e,_*=e,v*=e}if(h[0]=E(Math.round(d.x*r),Math.round(d.y*r),Math.round(d.z*r)),h[1]=E(Math.round(u.x*r),Math.round(u.y*r),Math.round(u.z*r)),h[0]===h[1])continue;if(h[2]=E(Math.round(g.x*r),Math.round(g.y*r),Math.round(g.z*r)),h[1]===h[2]||h[2]===h[0])continue;const U=[d,u,g];for(let e=0;e<3;e++){const n=(e+1)%3,t=h[e],r=h[n],i=U[e],a=U[n],s=E(t,r,0),l=E(r,t,0),c=D.get(l);if(void 0!==c)m*b[c]+_*w[c]+v*M[c]<=o&&(O[A++]=i.x,O[A++]=i.y,O[A++]=i.z,O[A++]=a.x,O[A++]=a.y,O[A++]=a.z),D.delete(l);else{const t=C++;D.set(s,t),x[t]=p[e],y[t]=p[n],b[t]=m,w[t]=_,M[t]=v}}}D.forEach((e=>{const n=x[e],t=y[e];l.fromBufferAttribute(s,n),c.fromBufferAttribute(s,t),O[A++]=l.x,O[A++]=l.y,O[A++]=l.z,O[A++]=c.x,O[A++]=c.y,O[A++]=c.z}));const I=O.slice(0,A);this.setAttribute("position",new i.a$l(I,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static taus(e,n,t,r,i){return((e&i)<<n^(e<<t^e)>>>r)>>>0}static hybridtaus(e,n,t,r=255){const i=e=>e>>>0;return e=f.taus(e,13,19,12,4294967294),n=f.taus(n,2,25,4,4294967288),t=f.taus(t,3,11,17,4294967280),r=i(1664525*r+1013904223),i(e^n^t^r)}}f._indexArray=[0,0,0],f._hashArray=new Array(3);var m=t(75);class p extends i.jyz{constructor(e,n){if(super(e),this.isColorableMergedMaterial=!0,this.initDefine=e=>{this.defines={INDEX:e}},0===n)throw new Error("ColorableMergedMaterialには少なくとも1つ以上のTweenableColorが必要です。\n        このMaterialに紐づけられたTweenableColoMapには1つもTweenableColorが登録されていません。");this.isColorableMergedMaterial=!0,this.initDefine(n)}static getColorUniform(e){return{colors:{value:new Array(e).fill(0).map((()=>new i.Ltg(1,1,1,.5)))}}}}class h extends p{constructor(e,n){super({vertexShader:"\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nattribute float MODEL_INDEX;\nvarying float colorTableIndex;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n  \n  colorTableIndex = MODEL_INDEX;\n}\n",fragmentShader:"\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying float colorTableIndex;\nuniform vec4[INDEX] colors;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n  //#include <color_fragment>\n  diffuseColor *= colors[int(colorTableIndex)];\n    \n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"},e.getSize()),this.colors=e,this.uniforms=h.getBasicUniforms(e.getSize()),this.transparent=!0,this.blending=n?.blending??i.bdR,this.side=n?.side??i.Wl3,e.setMaterial(this),e.updateUniformsAll()}static getBasicUniforms(e){return i.rDY.merge([m.rBU.common,m.rBU.specularmap,m.rBU.envmap,m.rBU.aomap,m.rBU.lightmap,m.rBU.fog,p.getColorUniform(e)])}}class _ extends p{constructor(e,n){super({vertexShader:"\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nattribute float MODEL_INDEX;\nvarying float colorTableIndex;\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n    \n  colorTableIndex = MODEL_INDEX;\n}\n",fragmentShader:"\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying float colorTableIndex;\nuniform vec4[INDEX] colors;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t//#include <color_fragment>\n  diffuseColor *= colors[int(colorTableIndex)];\n    \n  outgoingLight = diffuseColor.rgb; // simple shader\n\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}\n"},e.getSize()),this.colors=e,this.uniforms=_.getBasicUniforms(e.getSize()),this.depthWrite=n?.depthWrite??!0,this.transparent=!0,e.setMaterial(this),e.updateUniformsAll()}static getBasicUniforms(e){return i.rDY.merge([m.rBU.common,m.rBU.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}},p.getColorUniform(e)])}}var v=t(993);class x{constructor(e,n){this.geometries=[],this.object3D=e,this.option=n}async add(e,n,t){const r=await this.convert(e),o=n.getUniformIndex(t),a=function(e){return e.getAttribute("position").count}(r),l=new Uint16Array(a);for(let e=0;e<a;e++)l[e]=o;const c=new i.TlE(l,1);r.setAttribute(s.MODEL_INDEX,c),this.geometries.push(r)}async convert(e){return e}async merge(){0!==this.geometries.length?this.object3D.geometry=v.n4(this.geometries):this.object3D.parent?.remove(this.object3D)}}class y extends x{async convert(e){return e.deleteAttribute("uv"),e}}class b extends x{async convert(e){return this.option.useFastEdgesGeometry?new f(e,this.option.edgeDetail):new i.TOt(e,this.option.edgeDetail)}}var w=t(647),M=t(984),D=t(146);class C extends D.v{constructor(e){super(),this.uniformName=e,this.colors=new Map,w.k7.start()}setMaterial(e){this.material=e}static getColorMapKey(e){return`${e}`}add(e,n){const t=new w.ZM(255*e[0],255*e[1],255*e[2],e[3]);this.colors.set(C.getColorMapKey(n),t),t.on("onUpdate",(()=>{this.updateUniform(t)}))}get(e){return this.colors.get(C.getColorMapKey(e))}getUniformIndex(e){return[...this.colors.keys()].indexOf(C.getColorMapKey(e))}getUniformIndexFromColor(e){return[...this.colors.values()].indexOf(e)}getSize(){return this.colors.size}changeColor(e,n,t){t=t??{},t.now??=performance.now(),t.duration??=1e3,t.easing??=M.oY.Cubic.Out;const r=this.get(n);r?.change(255*e[0],255*e[1],255*e[2],e[3],t.duration,{easing:t.easing,startTime:t.now})}updateUniformsAll(){this.colors.forEach((e=>{this.updateUniform(e)}))}updateUniform(e){if(null==this.material)return;const n=this.material.uniforms[this.uniformName].value;if(null==n)return void console.error(`対象のマテリアルに、${this.uniformName}という名前のuniformが存在しません。${this.material.name}のuniform生成処理にこの名前のuniformを追加してください。`);const t=this.getUniformIndexFromColor(e),r=e.getAttribute();n[t].set(...r)}}const O=async(e,n,t,r,o,a,s)=>{const l=.1,c=new i.DvJ(l,l,l),d=n=>n<e/2?-1:1,u=d(n)*d(t)*d(r),g=n=>3*l*(n-e/2);c.translate(g(n),g(t),g(r)),a.add([1,1,1,.2],u),s.add([1,1,1,.8],u),await(o.body?.geometryMerger.add(c,a,u)),await(o.edge?.geometryMerger.add(c,s,u))};var A=t(12),E=t(304);window.onload=async()=>{const{scene:e}=(e=>{const n=new i.xsS,t=new i.cPb(45,1280/720,1,6e4);t.position.set(0,0,15);const r=new m.CP7({antialias:!0});r.setSize(1280,720),r.setClearColor(new i.Ilk(0)),document.body.appendChild(r.domElement);const o=document.createElement("div");document.body.appendChild(o),new A.z(t,r.domElement);const a=new E.Z,s=()=>{a.begin(),r.render(n,t),a.end(),o.innerText=JSON.stringify(r.info.render),requestAnimationFrame(s)};return s(),{scene:n,camera:t}})(),n=await async function(e=20,n){n=n??"webgl";const t=new s({bodyOption:{color:[1,1,1,.2]},edgeOption:{color:[1,1,1,.8]}}),r=new C("colors"),i=new C("colors");return await(async(e,n,t,r)=>{const i=[];for(let o=0;o<e;o++)for(let a=0;a<e;a++)for(let s=0;s<e;s++)i.push(O(e,o,a,s,n,t,r));await Promise.all(i),await n.merge()})(e,t,r,i),((e,n,t,r)=>{e.body&&(e.body.material=new r.bodyMaterialClass(n)),e.edge&&(e.edge.material=new r.edgeMaterialClass(t))})(t,r,i,{bodyMaterialClass:h,edgeMaterialClass:_}),t}();e.add(n),new r(n)}}},t={};function r(e){var i=t[e];if(void 0!==i)return i.exports;var o=t[e]={exports:{}};return n[e](o,o.exports,r),o.exports}r.m=n,e=[],r.O=(n,t,i,o)=>{if(!t){var a=1/0;for(d=0;d<e.length;d++){for(var[t,i,o]=e[d],s=!0,l=0;l<t.length;l++)(!1&o||a>=o)&&Object.keys(r.O).every((e=>r.O[e](t[l])))?t.splice(l--,1):(s=!1,o<a&&(a=o));if(s){e.splice(d--,1);var c=i();void 0!==c&&(n=c)}}return n}o=o||0;for(var d=e.length;d>0&&e[d-1][2]>o;d--)e[d]=e[d-1];e[d]=[t,i,o]},r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.j=577,(()=>{var e={577:0};r.O.j=n=>0===e[n];var n=(n,t)=>{var i,o,[a,s,l]=t,c=0;if(a.some((n=>0!==e[n]))){for(i in s)r.o(s,i)&&(r.m[i]=s[i]);if(l)var d=l(r)}for(n&&n(t);c<a.length;c++)o=a[c],r.o(e,o)&&e[o]&&e[o][0](),e[o]=0;return r.O(d)},t=self.webpackChunk_masatomakino_colorable_merged_model=self.webpackChunk_masatomakino_colorable_merged_model||[];t.forEach(n.bind(null,0)),t.push=n.bind(null,t.push.bind(t))})();var i=r.O(void 0,[736],(()=>r(496)));i=r.O(i)})();